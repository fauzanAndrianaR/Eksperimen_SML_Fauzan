import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.model_selection import train_test_split
import pickle
import os
import json

class PreprocessingPipeline:
    def __init__(self):
        self.scaler = StandardScaler()
        self.encoders = {}
        self.target_encoder = LabelEncoder()
        self.selected_features = [
            'Age', 'RestingBP', 'Cholesterol', 'FastingBS', 'MaxHR', 'Oldpeak',
            'Sex_encoded', 'ChestPainType_encoded', 'RestingECG_encoded',
            'ExerciseAngina_encoded', 'ST_Slope_encoded'
        ]

    def load_data(self, path):
        print(f"[üîç] Loading data from: {path}")
        return pd.read_csv(path)

    def handle_missing(self, df):
        df_filled = df.copy()
        print("[üßº] Filling missing values...")
        num_cols = ['Age', 'RestingBP', 'Cholesterol', 'MaxHR', 'Oldpeak']
        cat_cols = ['Sex', 'ChestPainType', 'RestingECG', 'ExerciseAngina', 'ST_Slope']

        for col in num_cols:
            if df_filled[col].isnull().any():
                median_val = df_filled[col].median()
                df_filled[col].fillna(median_val, inplace=True)
                print(f"  - {col}: filled with median {median_val}")

        for col in cat_cols:
            if df_filled[col].isnull().any():
                mode_val = df_filled[col].mode()[0]
                df_filled[col].fillna(mode_val, inplace=True)
                print(f"  - {col}: filled with mode '{mode_val}'")

        return df_filled

    def encode_categorical(self, df):
        print("[üî°] Encoding categorical features...")
        df_encoded = df.copy()
        categorical_columns = ['Sex', 'ChestPainType', 'RestingECG', 'ExerciseAngina', 'ST_Slope']

        for col in categorical_columns:
            encoder = LabelEncoder()
            df_encoded[col + '_encoded'] = encoder.fit_transform(df_encoded[col])
            self.encoders[col] = encoder
            print(f"  - {col}: {dict(zip(encoder.classes_, encoder.transform(encoder.classes_)))}")

        df_encoded['target'] = self.target_encoder.fit_transform(df_encoded['HeartDisease'])
        print(f"[üéØ] Target classes: {dict(zip(self.target_encoder.classes_, self.target_encoder.transform(self.target_encoder.classes_)))}")
        return df_encoded

    def separate_features_and_target(self, df):
        X = df[self.selected_features]
        y = df['target']
        return X, y

    def scale_features(self, X_train, X_test):
        print("[üìè] Scaling features...")
        X_train_scaled = self.scaler.fit_transform(X_train)
        X_test_scaled = self.scaler.transform(X_test)
        return pd.DataFrame(X_train_scaled, columns=X_train.columns), pd.DataFrame(X_test_scaled, columns=X_test.columns)

    def run_pipeline(self, data_path, output_dir, test_size=0.2, seed=42):
        print("[üöÄ] Running preprocessing steps...")
        df = self.load_data(data_path)
        df_clean = self.handle_missing(df)
        df_encoded = self.encode_categorical(df_clean)
        X, y = self.separate_features_and_target(df_encoded)
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_size, random_state=seed, stratify=y)
        X_train_scaled, X_test_scaled = self.scale_features(X_train, X_test)
        self.save_outputs(X_train_scaled, X_test_scaled, y_train, y_test, output_dir)

    def save_outputs(self, X_train, X_test, y_train, y_test, out_path):
        print(f"[üíæ] Saving results to {out_path}")
        os.makedirs(out_path, exist_ok=True)
        X_train.to_csv(f"{out_path}/X_train.csv", index=False)
        X_test.to_csv(f"{out_path}/X_test.csv", index=False)
        y_train.to_frame("target").to_csv(f"{out_path}/y_train.csv", index=False)
        y_test.to_frame("target").to_csv(f"{out_path}/y_test.csv", index=False)

        with open(f"{out_path}/scaler.pkl", "wb") as f:
            pickle.dump(self.scaler, f)

        with open(f"{out_path}/label_encoders.pkl", "wb") as f:
            pickle.dump(self.encoders, f)

        with open(f"{out_path}/target_encoder.pkl", "wb") as f:
            pickle.dump(self.target_encoder, f)

        with open(f"{out_path}/feature_info.json", "w") as f:
            json.dump({
                "features": self.selected_features,
                "target_classes": list(self.target_encoder.classes_)
            }, f, indent=2)

        print("[‚úÖ] Preprocessing completed and saved.")

